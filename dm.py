import argparse
import re
import stat
import tarfile
import time
from enum import Enum
from io import BytesIO
from pathlib import Path
from typing import BinaryIO

__version__ = "0.0.1"


class CompressionType(Enum):
    """Compression types for the data archive"""

    LZMA = "xz"
    GZIP = "gz"
    BZIP2 = "bz2"


class Dm(object):
    """Minimal dpkg-deb clone"""

    @classmethod
    def build_package(
        cls,
        in_directory: str,
        destination: str,
        compression: CompressionType = CompressionType.LZMA,
        compression_level: int = 9,
    ) -> None:
        """Build a deb file from the contents of the provided directory, using the specifed compression algorithm"""

        in_path = Path(in_directory)

        # Build the debian-archive file. It contains a single line giving the package format version number
        debian_bin = BytesIO(b"2.0")

        # Build the control archive
        control_tar = Dm._build_control_archive(in_path)

        # Build the data archive
        data_archive = Dm._build_data_archive(in_path, compression, compression_level)

        # Build the deb file
        with open(destination, mode="wb") as debf:
            # Magic bytes
            debf.write(b"!<arch>\n")
            # Add files
            Dm._add_file_to_archive("debian-binary", debian_bin, debf)
            Dm._add_file_to_archive("control.tar.gz", control_tar, debf)
            # Data archive suffix depends on compression type
            data_archive_name = f"data.tar.{compression.value}"
            Dm._add_file_to_archive(data_archive_name, data_archive, debf)

    @classmethod
    def _add_file_to_archive(cls, name: str, data: BytesIO, archive: BinaryIO) -> None:
        """Add a file into an AR archive"""
        # Write the file name
        filename = name.ljust(16, " ").encode("utf-8")
        archive.write(filename)

        # File timestamp - use current time
        timestamp = str(int(time.time())).ljust(12, " ").encode("utf-8")
        archive.write(timestamp)

        # UID and GID (both 0)
        uid = "0".ljust(6, " ").encode("utf-8")
        archive.write(uid)
        gid = "0".ljust(6, " ").encode("utf-8")
        archive.write(gid)

        # File permissions
        mode = "0100644".ljust(8, " ").encode("utf-8")
        archive.write(mode)

        # File length
        file_data = data.getvalue()
        size = str(len(file_data)).ljust(10, " ").encode("utf-8")
        archive.write(size)

        # End of file meta-data
        archive.write(b"`\n")

        # Write file data
        archive.write(file_data)
        if len(file_data) % 2 == 1:
            archive.write(b"\n")

    @classmethod
    def _build_control_archive(cls, directory: Path) -> BytesIO:
        """Compress the control archive (DEBIAN) into a gzipped tarball"""
        # There needs to be a directory called DEBIAN in the root of the provided path
        control_directory = directory / "DEBIAN"
        if not control_directory.exists() or not control_directory.is_dir():
            raise Exception("control directory is invalid")

        # The DEBIAN directory should contain a file called control
        control_file = control_directory / "control"
        if not control_file.exists():
            raise Exception("control file missing")

        # Build the archive
        control_tar = BytesIO()
        with tarfile.open(fileobj=control_tar, mode="w:gz") as tarf:
            for f in control_directory.iterdir():
                # Skip .DS_Store files generated by macOS
                if f.name == ".DS_Store":
                    continue

                # Permissions should be >=0555 and <=0775
                file_mode = oct(stat.S_IMODE(f.stat().st_mode))
                if file_mode < oct(0o0555) or file_mode > oct(0o0775):
                    raise Exception(
                        f'Invalid permissions on file "{f.name}". Have {int(file_mode, base=8)}, should be >=0555 and <=0775'
                    )

                # Add the files to the root of the archive
                tarf.add(f.as_posix(), arcname=f.name)

        # Parse the control file. This happens after the permissions checks, because doing this requires the ability to read the file.
        # If the file cannot be read, the desired exception is invalid file permissions
        cls._validate_control_file(control_file)

        return control_tar

    @classmethod
    def _validate_control_file(cls, control_file: Path) -> None:
        """Validate the contents of the control file"""
        # Parse the control file
        control_data = {}
        for file_line in control_file.read_text().splitlines():
            components = file_line.split(":")
            if len(components) < 2:
                continue
            fieldname = components[0].strip().lower()
            control_data[fieldname] = components[1].strip()

        # Check to see if the requires fields are present (ignoring case)
        for key in ["package", "version", "architecture"]:
            if key not in control_data:
                raise Exception(f"control file is missing {key}")

        # Validate package name
        if re.search(r"[^a-z0-9+-.]", control_data["package"]):
            raise Exception("Package name has characters that aren't lowercase alphanums or '-+.'.")

        # Validate version
        if not re.search(r"[0-9]", control_data["version"]):
            raise Exception(f"Package version {control_data['version']} doesn't contain any digits.")

    @classmethod
    def _build_data_archive(cls, directory: Path, compression: CompressionType, compression_level: int = 9) -> BytesIO:
        """Compress the package's files"""
        data_archive = BytesIO()
        # LZMA uses a different name for "compression level" (wtf). "preset" for lzma, 'compresslevel" for everything else
        compression_argname = "preset" if compression is CompressionType.LZMA else "compresslevel"
        tarmode = f"w:{compression.value}"
        with tarfile.open(fileobj=data_archive, mode=tarmode, **{compression_argname: compression_level}) as tarf:  # type: ignore
            for f in directory.glob("**/*"):
                # Exclude all directories and anything within DEBIAN/
                if f.is_dir() or f.parent.name == "DEBIAN":
                    continue

                # Skip .DS_Store files generated by macOS
                if f.name == ".DS_Store":
                    continue

                # Add the file to the archive, using a path relative to the input directory
                relative_path = f.relative_to(directory)
                tarf.add(f.as_posix(), arcname=f"/{relative_path.as_posix()}")
        return data_archive


if __name__ == "__main__":

    args = argparse.ArgumentParser()
    args.add_argument("-b", action="store_true")
    args.add_argument("-z", type=int, action="store", dest="compresslevel", default=9, help="Compression level (0-9)")
    args.add_argument(
        "-Z",
        action="store",
        dest="compression",
        default="lzma",
        choices=["lzma", "gz", "bz2"],
        help="Compression type (lzma, gz, bz2)",
    )
    args.add_argument("directory", type=str, action="store", help="The directory to package")
    args.add_argument("package", type=str, action="store", help="Output package")

    parsed_args = args.parse_args()

    compression_type = {
        "lzma": CompressionType.LZMA,
        "gz": CompressionType.GZIP,
        "bz2": CompressionType.BZIP2,
    }[parsed_args.compression]

    Dm.build_package(
        in_directory=parsed_args.directory,
        destination=parsed_args.package,
        compression=compression_type,
        compression_level=parsed_args.compresslevel,
    )
